#1 kiểm tra số nguyên tố :
bool ktra(int n){
  for(int i=2;i*i<=n;i++){
    if(n%i==0) return 0;
  }
  return n>1;
}
#2 số chính phương : 
bool cp(ll n){
  int cp=sqrt(n);
  return cp*cp==n;
}
#3 đếm ước : 
int demuoc(int n){
  int dem=0;
  for(int i=2;i*i<=n;i++){
    if(n%i==0){
      dem++;
      if(i!=n/i) dem++;
    }
  }
  return dem;
}
#4 phân tích thừa số nguyên tố :
ll thuant(ll n){
  for(int i=2;i*i<=n;i++){
    if(n%i==0){
      while(n%i==0){
        cout<<i<<" ";
        n/=i;       //15 ko chia hết cho 2 thì xét i=3 
      }
    }
  }
  if(n>1) return n;
}
#5 tổ chập k của n : n!/k!*(n-k)! -> gọi hàm gt 
#6 số hoàn hảo là số có các ước nhỏ hơn nó và có tổng bằng nó  -> nên đặt sum=1 vì 1 luôn có ước của nó 
vd : 28 -> 1 2 4 7 14 = 28 
bool hoanhao(int n){
  if(n<2) return false;
  int sum=1;
  for(int i=2;i*i<=n;i++){
    if(n%i==0){
      sum+=i;
      if(i!=n/i) sum+=n/i;
      cout<<i<<" "<<n/i<<" ";
    }
  }
  return sum==n;
}
#7 số thuận nghịch là số đối xứng //vd 1221 đọc ngược lại là 1221 
rev=rev*10+n%10;
#ước chung lớn nhất && bội chung nhỏ nhất
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;  // Lưu b vào biến tạm
        b = a % b;     // Cập nhật b = phần dư của a chia b
        a = temp;      // Gán giá trị cũ của b cho a
    }
    return a;  // Khi b == 0, a là GCD
}
int lcm(int a, int b) {
    return (a / gcd(a, b)) * b;  // Tránh tràn số
}
